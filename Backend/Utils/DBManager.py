# Import the SQLite3 module for interacting with the SQLite database
import sqlite3

# Import custom classes used for settings and data representation
from Backend.ProgramSettings import ProgramSettings  # Contains the database file path

class DBManager:
    def __init__(self):
        """
        Constructor: Initializes the DBManager instance.

        - Establishes a connection to the SQLite database using a path specified in ProgramSettings.
        - Immediately ensures that the required tables exist by calling CreateTableIfNotExists().
        """
        self.connection = sqlite3.connect(ProgramSettings.DATABASE_PATH)  # Connect to DB
        self.CreateTableIfNotExists()  # Ensure schema is ready

    def CreateTableIfNotExists(self):
        """
        Ensures the existence of two main tables: 'values' and 'saves'.

        - 'values': stores users password-records with a Name and Key.
        - 'saves': stores saves

        Also:
        - Inserts a default user entry if one doesn't already exist.
        """

        # Enable foreign key support (SQLite does not enable it by default)
        self.connection.execute("PRAGMA foreign_keys = ON")

        # SQL command to create the 'values' table if it doesn't exist
        create_values_table = """
            CREATE TABLE IF NOT EXISTS "values" (
                ValueId INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT NOT NULL,
                Key TEXT NOT NULL
            )
        """
        self.connection.execute(create_values_table)

        # SQL command to create the 'saves' table if it doesn't exist
        create_saves_table = """
            CREATE TABLE IF NOT EXISTS saves (
                SaveId INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT NOT NULL,
                Value TEXT NOT NULL
            )
        """

        self.connection.execute(create_saves_table)

        # Check if a default 'user' save already exists
        cursor = self.connection.execute("SELECT COUNT(*) FROM saves WHERE Name = ?", ("user",))
        exists = cursor.fetchone()[0] > 0

        if not exists:
            # Insert a corresponding save record for the default user
            self.connection.execute(
                'INSERT INTO saves (ValueId, Name, Value) VALUES (?, ?, ?)',
                (1, "user", "7ZCsDFCTYGYFYWxADFBAJ1ZtjPZYVWNEVhj1J+++O5I=")
            )

        # Commit all changes to make them persistent in the database
        self.connection.commit()

    def tableValues_CreateValue(self, name: str, key: str) -> int:
        """
        Inserts a new row into the 'values' table.

        Parameters:
            name (str): The name to insert.
            key (str): The key to insert.

        Returns:
            int: The ID of the newly inserted row (autogenerated by SQLite).
        """
        insert_query = 'INSERT INTO "values" (Name, Key) VALUES (?, ?)'
        cursor = self.connection.execute(insert_query, (name, key))
        self.connection.commit()
        return cursor.lastrowid  # Return the auto-generated ValueId

    def tableValues_SaveValue(self, name: str, key: str) -> bool:
        """
        Updates the 'Key' of an existing row in the 'values' table where the Name matches.

        Parameters:
            name (str): The name identifying the row to update.
            key (str): The new key value to set.

        Returns:
            bool: True if the update affected at least one row, otherwise False.
        """
        update_query = 'UPDATE "values" SET Key = ? WHERE Name = ?'
        cursor = self.connection.execute(update_query, (key, name))
        self.connection.commit()
        return cursor.rowcount > 0  # True if at least one row was updated
    
    def tableValues_GetValue(self, name: str) -> str:
        resultValue = ""
        update_query = 'SELECT * FROM "values" WHERE Name = ?'
        cursor = self.connection.execute(update_query, (name,))  # Note the tuple for parameter
        self.connection.commit()
        for row in cursor:
            resultValue = row[0]
        return resultValue

    def tableValues_DeleteValue(self, name: str) -> bool:
        """
        Deletes a row from the 'values' table based on the Name.

        Parameters:
            name (str): The name of the value to delete.

        Returns:
            bool: True if a row was deleted, otherwise False.
        """
        delete_query = 'DELETE FROM "values" WHERE Name = ?'
        cursor = self.connection.execute(delete_query, (name,))
        self.connection.commit()
        return cursor.rowcount > 0  # True if a row was deleted

    def tableValues_GetAllValues(self) -> list[tuple]:
        """
        Retrieves all rows from the 'values' table and returns them as a list of tuples.

        Returns:
            list[tuple]: A list of (ValueId, Name, Key) tuples from the database.
        """
        query = 'SELECT ValueId, Name, Key FROM "values"'
        cursor = self.connection.execute(query)

        values_list = []
        for row in cursor:
            values_list.append((row[1], row[2]))  # Append tuple directly
        return values_list

    def tableSaves_UpdateSave(self, save_id: int, name: str, value: str) -> bool:
        """
        Updates a row in the 'saves' table by its SaveId.

        Parameters:
            save_id (int): ID of the save entry to update.
            name (str): New name for the save.
            value (str): New value to store.

        Returns:
            bool: True if update succeeded, False if no row was affected.
        """
        update_query = 'UPDATE saves SET Name = ?, Value = ? WHERE SaveId = ?'
        cursor = self.connection.execute(update_query, (name, value, save_id))
        self.connection.commit()
        return cursor.rowcount > 0  # rowcount > 0 means successful update

    def tableSaves_GetSave(self, save_id: int) -> str | None:
        """
        Retrieves the 'Value' field from a save record.

        Parameters:
            save_id (int): ID of the desired save record.

        Returns:
            str | None: Returns the saved value string if found, otherwise None.
        """
        query = 'SELECT Value FROM saves WHERE SaveId = ?'
        cursor = self.connection.execute(query, (save_id,))
        row = cursor.fetchone()
        return row[0] if row else None  # Return the value if found, else None