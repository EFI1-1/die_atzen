# Import the SQLite3 module for interacting with SQLite databases
import sqlite3

# Import application settings (e.g., database path)
from Backend.ProgramSettings import ProgramSettings  # This should define DATABASE_PATH


class DBManager:
    def __init__(self):
        """
        Initializes the DBManager.

        - Connects to the SQLite database using the path provided in ProgramSettings.
        - Ensures the required database tables exist by invoking CreateTableIfNotExists().
        """
        self.connection = sqlite3.connect(ProgramSettings.DATABASE_PATH)
        self.CreateTableIfNotExists()

    def CreateTableIfNotExists(self):
        """
        Creates the necessary database tables if they do not exist.

        Tables:
        - 'values': Stores (Name, Key) pairs for user data.
        - 'saves': Stores saved data with a Name and Value.

        Also inserts a default user record into 'saves' if it does not already exist.
        """
        self.connection.execute("PRAGMA foreign_keys = ON")  # Ensure foreign key support

        # SQL for creating the 'values' table
        create_values_table = """
            CREATE TABLE IF NOT EXISTS "values" (
                ValueId INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT NOT NULL,
                Key TEXT NOT NULL
            )
        """
        self.connection.execute(create_values_table)

        # SQL for creating the 'saves' table
        create_saves_table = """
            CREATE TABLE IF NOT EXISTS saves (
                SaveId INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT NOT NULL,
                Value TEXT NOT NULL
            )
        """
        self.connection.execute(create_saves_table)

        # Check if a 'user' save already exists
        cursor = self.connection.execute("SELECT COUNT(*) FROM saves WHERE Name = ?", ("user",))
        exists = cursor.fetchone()[0] > 0

        if not exists:
            # Insert default 'user' save (Note: no ValueId column in 'saves'; likely an error)
            self.connection.execute(
                'INSERT INTO saves (Name, Value) VALUES (?, ?)',
                ("user", "7ZCsDFCTYGYFYWxADFBAJ1ZtjPZYVWNEVhj1J+++O5I=")
            )

        self.connection.commit()

    def tableValues_CreateValue(self, name: str, key: str) -> int:
        """
        Inserts a new record into the 'values' table.

        Parameters:
            name (str): The name to associate with the key.
            key (str): The key to store.

        Returns:
            int: The autogenerated ValueId of the new entry.
        """
        insert_query = 'INSERT INTO "values" (Name, Key) VALUES (?, ?)'
        cursor = self.connection.execute(insert_query, (name, key))
        self.connection.commit()
        return cursor.lastrowid

    def tableValues_SaveValue(self, name: str, key: str) -> bool:
        """
        Updates the key for an existing name in the 'values' table.

        Parameters:
            name (str): The name identifying the record to update.
            key (str): The new key value.

        Returns:
            bool: True if at least one record was updated, False otherwise.
        """
        update_query = 'UPDATE "values" SET Key = ? WHERE Name = ?'
        cursor = self.connection.execute(update_query, (key, name))
        self.connection.commit()
        return cursor.rowcount > 0

    def tableValues_GetValue(self, name: str) -> str | None:
        """
        Retrieves the key associated with a given name from the 'values' table.

        Parameters:
            name (str): The name whose associated key is to be fetched.

        Returns:
            str | None: The associated key, or None if not found.
        """
        query = 'SELECT Key FROM "values" WHERE Name = ?'
        cursor = self.connection.execute(query, (name,))
        row = cursor.fetchone()
        return row[0] if row else None

    def tableValues_DeleteValue(self, name: str) -> bool:
        """
        Deletes a record from the 'values' table by name.

        Parameters:
            name (str): The name of the value to delete.

        Returns:
            bool: True if a record was deleted, False otherwise.
        """
        delete_query = 'DELETE FROM "values" WHERE Name = ?'
        cursor = self.connection.execute(delete_query, (name,))
        self.connection.commit()
        return cursor.rowcount > 0

    def tableValues_GetAllValues(self) -> list[tuple[str, str]]:
        """
        Retrieves all (Name, Key) pairs from the 'values' table.

        Returns:
            list[tuple[str, str]]: List of tuples containing Name and Key.
        """
        query = 'SELECT Name, Key FROM "values"'
        cursor = self.connection.execute(query)

        values_list = []
        for row in cursor:
            values_list.append((row[0], row[1]))  # row[0] = Name, row[1] = Key
        return values_list

    def tableSaves_UpdateSave(self, save_id: int, name: str, value: str) -> bool:
        """
        Updates a save record by its ID.

        Parameters:
            save_id (int): The ID of the save to update.
            name (str): The new name for the save.
            value (str): The new value to store.

        Returns:
            bool: True if the update was successful, False otherwise.
        """
        update_query = 'UPDATE saves SET Name = ?, Value = ? WHERE SaveId = ?'
        cursor = self.connection.execute(update_query, (name, value, save_id))
        self.connection.commit()
        return cursor.rowcount > 0

    def tableSaves_GetSave(self, save_id: int) -> str | None:
        """
        Retrieves the saved value for a given save ID.

        Parameters:
            save_id (int): The ID of the save record.

        Returns:
            str | None: The saved value string, or None if not found.
        """
        query = 'SELECT Value FROM saves WHERE SaveId = ?'
        cursor = self.connection.execute(query, (save_id,))
        row = cursor.fetchone()
        return row[0] if row else None