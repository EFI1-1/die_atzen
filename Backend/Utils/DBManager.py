# Import the SQLite3 module for interacting with the SQLite database
import sqlite3

# Import custom classes used for settings and data representation
from Backend.ProgramSettings import ProgramSettings  # Contains the database file path
from Backend.Value import Value  # Represents a structured object for the 'values' table

class DBManager:
    def __init__(self):
        """
        Constructor: Initializes the DBManager instance.

        - Establishes a connection to the SQLite database using a path specified in ProgramSettings.
        - Immediately ensures that the required tables exist by calling CreateTableIfNotExists().
        """
        self.connection = sqlite3.connect(ProgramSettings.DATABASE_PATH)  # Connect to DB
        self.CreateTableIfNotExists()  # Ensure schema is ready

    def CreateTableIfNotExists(self):
        """
        Ensures the existence of two main tables: 'values' and 'saves'.

        - 'values': Stores metadata records with a Name and Key.
        - 'saves': Stores actual saved entries linked to a Value via foreign key.

        Also:
        - Enforces foreign key constraints.
        - Inserts a default user entry if one doesn't already exist.
        """

        # Enable foreign key support (SQLite does not enable it by default)
        self.connection.execute("PRAGMA foreign_keys = ON")

        # SQL command to create the 'values' table if it doesn't exist
        create_values_table = """
            CREATE TABLE IF NOT EXISTS "values" (
                ValueId INTEGER PRIMARY KEY AUTOINCREMENT,
                Name TEXT NOT NULL,
                Key TEXT NOT NULL
            )
        """
        self.connection.execute(create_values_table)

        # SQL command to create the 'saves' table if it doesn't exist
        create_saves_table = """
            CREATE TABLE IF NOT EXISTS saves (
                SaveId INTEGER PRIMARY KEY AUTOINCREMENT,
                ValueId INTEGER NOT NULL,
                Name TEXT NOT NULL,
                Value TEXT NOT NULL,
                FOREIGN KEY (ValueId) REFERENCES "values" (ValueId) ON DELETE CASCADE
            )
        """
        self.connection.execute(create_saves_table)

        # Check if a default 'user' save already exists
        cursor = self.connection.execute("SELECT COUNT(*) FROM saves WHERE Name = ?", ("user",))
        exists = cursor.fetchone()[0] > 0

        if not exists:
            # Insert a default entry in 'values' table
            cursor = self.connection.execute(
                'INSERT INTO "values" (Name, Key) VALUES (?, ?)',
                ("default_user_entry", "system_generated")
            )

            # Get the ID of the inserted value using SQLite's last insert rowid
            default_value_id = self.connection.execute('SELECT last_insert_rowid()').fetchone()[0]

            # Insert a corresponding save record for the default user
            self.connection.execute(
                'INSERT INTO saves (ValueId, Name, Value) VALUES (?, ?, ?)',
                (default_value_id, "user", "passwort")
            )

        # Commit all changes to make them persistent in the database
        self.connection.commit()

    def CreateValue(self, value: Value) -> int:
        """
        Inserts a new row into the 'values' table.

        Parameters:
            value (Value): Object containing 'name' and 'key' (id is ignored here).

        Returns:
            int: The ID of the newly inserted row (autogenerated by SQLite).
        """
        insert_query = 'INSERT INTO "values" (Name, Key) VALUES (?, ?)'
        cursor = self.connection.execute(insert_query, (value.name, value.key))
        self.connection.commit()
        return cursor.lastrowid  # Return the auto-generated ValueId

    def SaveValue(self, value: Value) -> bool:
        """
        Updates an existing row in the 'values' table.

        Parameters:
            value (Value): Object with existing id and updated name/key.

        Returns:
            bool: True if the update affected at least one row, otherwise False.
        """
        update_query = 'UPDATE "values" SET Name = ?, Key = ? WHERE ValueId = ?'
        cursor = self.connection.execute(update_query, (value.name, value.key, value.id))
        self.connection.commit()
        return cursor.rowcount > 0  # rowcount > 0 means successful update

    def DeleteValue(self, value: Value) -> bool:
        """
        Deletes a row from the 'values' table.

        Parameters:
            value (Value): Object containing the id to delete.

        Returns:
            bool: True if a row was deleted, otherwise False.
        """
        delete_query = 'DELETE FROM "values" WHERE ValueId = ?'
        cursor = self.connection.execute(delete_query, (value.id,))
        self.connection.commit()
        return cursor.rowcount > 0  # rowcount > 0 means delete occurred

    def GetAllValues(self) -> list[Value]:
        """
        Retrieves all rows from the 'values' table and constructs Value objects.

        Returns:
            list[Value]: A list of all Value records from the database.
        """
        query = 'SELECT ValueId, Name, Key FROM "values"'
        cursor = self.connection.execute(query)

        values_list = []
        for row in cursor:
            value_obj = Value(id=row[0], name=row[1], key=row[2])  # Reconstruct object
            values_list.append(value_obj)

        return values_list

    def UpdateSave(self, save_id: int, name: str, value: str) -> bool:
        """
        Updates a row in the 'saves' table by its SaveId.

        Parameters:
            save_id (int): ID of the save entry to update.
            name (str): New name for the save.
            value (str): New value to store.

        Returns:
            bool: True if update succeeded, False if no row was affected.
        """
        update_query = 'UPDATE saves SET Name = ?, Value = ? WHERE SaveId = ?'
        cursor = self.connection.execute(update_query, (name, value, save_id))
        self.connection.commit()
        return cursor.rowcount > 0  # rowcount > 0 means successful update

    def GetSave(self, save_id: int) -> str | None:
        """
        Retrieves the 'Value' field from a save record.

        Parameters:
            save_id (int): ID of the desired save record.

        Returns:
            str | None: Returns the saved value string if found, otherwise None.
        """
        query = 'SELECT Value FROM saves WHERE SaveId = ?'
        cursor = self.connection.execute(query, (save_id,))
        row = cursor.fetchone()
        return row[0] if row else None  # Return the value if found, else None
